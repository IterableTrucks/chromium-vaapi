diff -up chromium-62.0.3202.62/base/bind_helpers.h.epel7-c++11 chromium-62.0.3202.62/base/bind_helpers.h
--- chromium-62.0.3202.62/base/bind_helpers.h.epel7-c++11	2017-10-25 08:50:15.692276363 -0400
+++ chromium-62.0.3202.62/base/bind_helpers.h	2017-10-25 08:50:39.977611740 -0400
@@ -282,7 +282,7 @@ class PassedWrapper {
 };
 
 template <typename T>
-using Unwrapper = BindUnwrapTraits<std::decay_t<T>>;
+using Unwrapper = BindUnwrapTraits<typename std::decay<T>::type>;
 
 template <typename T>
 auto Unwrap(T&& o) -> decltype(Unwrapper<T>::Unwrap(std::forward<T>(o))) {
diff -up chromium-62.0.3202.62/base/bind.h.epel7-c++11 chromium-62.0.3202.62/base/bind.h
--- chromium-62.0.3202.62/base/bind.h.epel7-c++11	2017-10-25 08:55:22.603877014 -0400
+++ chromium-62.0.3202.62/base/bind.h	2017-10-25 08:56:41.636714097 -0400
@@ -53,7 +53,7 @@ struct AssertConstructible {
   // reference with repeating callbacks--is used instead of base::Passed().
   static_assert(
       param_is_forwardable ||
-          !std::is_constructible<Param, std::decay_t<Unwrapped>&&>::value,
+          !std::is_constructible<Param, typename std::decay<Unwrapped>::type&&>::value,
       "Bound argument |i| is move-only but will be forwarded by copy. "
       "Ensure |Arg| is bound using base::Passed(), not std::move().");
   static_assert(
@@ -64,7 +64,7 @@ struct AssertConstructible {
   static constexpr bool arg_is_storable =
       std::is_constructible<Storage, Arg>::value;
   static_assert(arg_is_storable ||
-                    !std::is_constructible<Storage, std::decay_t<Arg>&&>::value,
+                    !std::is_constructible<Storage, typename std::decay<Arg>::type&&>::value,
                 "Bound argument |i| is move-only but will be bound by copy. "
                 "Ensure |Arg| is mutable and bound using std::move().");
   static_assert(arg_is_storable,
@@ -88,7 +88,7 @@ struct AssertBindArgsValidity<std::index
                               TypeList<Args...>,
                               TypeList<Unwrapped...>,
                               TypeList<Params...>>
-    : AssertConstructible<Ns, Args, std::decay_t<Args>, Unwrapped, Params>... {
+    : AssertConstructible<Ns, Args, typename std::decay<Args>::type, Unwrapped, Params>... {
   static constexpr bool ok = true;
 };
 
@@ -98,14 +98,14 @@ struct TransformToUnwrappedTypeImpl;
 
 template <typename T>
 struct TransformToUnwrappedTypeImpl<true, T> {
-  using StoredType = std::decay_t<T>;
+  using StoredType = typename std::decay<T>::type;
   using ForwardType = StoredType&&;
   using Unwrapped = decltype(Unwrap(std::declval<ForwardType>()));
 };
 
 template <typename T>
 struct TransformToUnwrappedTypeImpl<false, T> {
-  using StoredType = std::decay_t<T>;
+  using StoredType = typename std::decay<T>::type;
   using ForwardType = const StoredType&;
   using Unwrapped = decltype(Unwrap(std::declval<ForwardType>()));
 };
@@ -153,7 +153,7 @@ using MakeUnwrappedTypeList =
 template <typename Functor, typename... Args>
 inline OnceCallback<MakeUnboundRunType<Functor, Args...>>
 BindOnce(Functor&& functor, Args&&... args) {
-  static_assert(!internal::IsOnceCallback<std::decay_t<Functor>>() ||
+  static_assert(!internal::IsOnceCallback<typename std::decay<Functor>::type>() ||
                     (std::is_rvalue_reference<Functor&&>() &&
                      !std::is_const<std::remove_reference_t<Functor>>()),
                 "BindOnce requires non-const rvalue for OnceCallback binding."
@@ -197,7 +197,7 @@ template <typename Functor, typename...
 inline RepeatingCallback<MakeUnboundRunType<Functor, Args...>>
 BindRepeating(Functor&& functor, Args&&... args) {
   static_assert(
-      !internal::IsOnceCallback<std::decay_t<Functor>>(),
+      !internal::IsOnceCallback<typename std::decay<Functor>::type>(),
       "BindRepeating cannot bind OnceCallback. Use BindOnce with std::move().");
 
   // This block checks if each |args| matches to the corresponding params of the
diff -up chromium-62.0.3202.62/base/bind_internal.h.epel7-c++11 chromium-62.0.3202.62/base/bind_internal.h
--- chromium-62.0.3202.62/base/bind_internal.h.epel7-c++11	2017-10-25 08:52:20.018873878 -0400
+++ chromium-62.0.3202.62/base/bind_internal.h	2017-10-25 08:55:07.779282724 -0400
@@ -256,7 +256,7 @@ struct FunctorTraits<RepeatingCallback<R
 };
 
 template <typename Functor>
-using MakeFunctorTraits = FunctorTraits<std::decay_t<Functor>>;
+using MakeFunctorTraits = FunctorTraits<typename std::decay<Functor>::type>;
 
 // InvokeHelper<>
 //
@@ -341,7 +341,7 @@ struct Invoker<StorageType, R(UnboundArg
                           UnboundArgs&&... unbound_args) {
     static constexpr bool is_method = MakeFunctorTraits<Functor>::is_method;
 
-    using DecayedArgsTuple = std::decay_t<BoundArgsTuple>;
+    using DecayedArgsTuple = typename std::decay<BoundArgsTuple>::type;
     static constexpr bool is_weak_call =
         IsWeakMethod<is_method,
                      std::tuple_element_t<indices, DecayedArgsTuple>...>();
@@ -479,33 +479,33 @@ struct MakeBindStateTypeImpl;
 
 template <typename Functor, typename... BoundArgs>
 struct MakeBindStateTypeImpl<false, Functor, BoundArgs...> {
-  static_assert(!HasRefCountedTypeAsRawPtr<std::decay_t<BoundArgs>...>::value,
+  static_assert(!HasRefCountedTypeAsRawPtr<typename std::decay<BoundArgs>::type...>::value,
                 "A parameter is a refcounted type and needs scoped_refptr.");
-  using Type = BindState<std::decay_t<Functor>, std::decay_t<BoundArgs>...>;
+  using Type = BindState<typename std::decay<Functor>::type, typename std::decay<BoundArgs>::type...>;
 };
 
 template <typename Functor>
 struct MakeBindStateTypeImpl<true, Functor> {
-  using Type = BindState<std::decay_t<Functor>>;
+  using Type = BindState<typename std::decay<Functor>::type>;
 };
 
 template <typename Functor, typename Receiver, typename... BoundArgs>
 struct MakeBindStateTypeImpl<true, Functor, Receiver, BoundArgs...> {
   static_assert(!std::is_array<std::remove_reference_t<Receiver>>::value,
                 "First bound argument to a method cannot be an array.");
-  static_assert(!HasRefCountedTypeAsRawPtr<std::decay_t<BoundArgs>...>::value,
+  static_assert(!HasRefCountedTypeAsRawPtr<typename std::decay<BoundArgs>::type...>::value,
                 "A parameter is a refcounted type and needs scoped_refptr.");
 
  private:
-  using DecayedReceiver = std::decay_t<Receiver>;
+  using DecayedReceiver = typename std::decay<Receiver>::type;
 
  public:
   using Type = BindState<
-      std::decay_t<Functor>,
+      typename std::decay<Functor>::type,
       std::conditional_t<std::is_pointer<DecayedReceiver>::value,
                          scoped_refptr<std::remove_pointer_t<DecayedReceiver>>,
                          DecayedReceiver>,
-      std::decay_t<BoundArgs>...>;
+      typename std::decay<BoundArgs>::type...>;
 };
 
 template <typename Functor, typename... BoundArgs>
diff -up chromium-62.0.3202.62/base/containers/span.h.epel7-c++11 chromium-62.0.3202.62/base/containers/span.h
--- chromium-62.0.3202.62/base/containers/span.h.epel7-c++11	2017-10-25 08:51:25.260372472 -0400
+++ chromium-62.0.3202.62/base/containers/span.h	2017-10-25 08:52:07.597213826 -0400
@@ -27,7 +27,7 @@ template <typename T>
 struct IsSpanImpl<span<T>> : std::true_type {};
 
 template <typename T>
-using IsSpan = IsSpanImpl<std::decay_t<T>>;
+using IsSpan = IsSpanImpl<typename std::decay<T>::type>;
 
 template <typename T>
 struct IsStdArrayImpl : std::false_type {};
@@ -36,7 +36,7 @@ template <typename T, size_t N>
 struct IsStdArrayImpl<std::array<T, N>> : std::true_type {};
 
 template <typename T>
-using IsStdArray = IsStdArrayImpl<std::decay_t<T>>;
+using IsStdArray = IsStdArrayImpl<typename std::decay<T>::type>;
 
 template <typename From, typename To>
 using IsLegalSpanConversion = std::is_convertible<From*, To*>;
