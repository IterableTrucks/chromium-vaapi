diff -up chromium-62.0.3202.62/base/bind_helpers.h.epel7-c++11 chromium-62.0.3202.62/base/bind_helpers.h
--- chromium-62.0.3202.62/base/bind_helpers.h.epel7-c++11	2017-10-25 08:50:15.692276363 -0400
+++ chromium-62.0.3202.62/base/bind_helpers.h	2017-10-25 09:12:15.889484145 -0400
@@ -282,7 +282,7 @@ class PassedWrapper {
 };
 
 template <typename T>
-using Unwrapper = BindUnwrapTraits<std::decay_t<T>>;
+using Unwrapper = BindUnwrapTraits<typename std::decay<T>::type>;
 
 template <typename T>
 auto Unwrap(T&& o) -> decltype(Unwrapper<T>::Unwrap(std::forward<T>(o))) {
@@ -438,7 +438,7 @@ static inline internal::OwnedWrapper<T>
 // Both versions of Passed() prevent T from being an lvalue reference. The first
 // via use of enable_if, and the second takes a T* which will not bind to T&.
 template <typename T,
-          std::enable_if_t<!std::is_lvalue_reference<T>::value>* = nullptr>
+          typename std::enable_if<!std::is_lvalue_reference<T>::value>::type* = nullptr>
 static inline internal::PassedWrapper<T> Passed(T&& scoper) {
   return internal::PassedWrapper<T>(std::move(scoper));
 }
@@ -537,9 +537,9 @@ template <typename Functor, typename...
 struct CallbackCancellationTraits<
     Functor,
     std::tuple<BoundArgs...>,
-    std::enable_if_t<
+    typename std::enable_if<
         internal::IsWeakMethod<internal::FunctorTraits<Functor>::is_method,
-                               BoundArgs...>::value>> {
+                               BoundArgs...>::value>::type> {
   static constexpr bool is_cancellable = true;
 
   template <typename Receiver, typename... Args>
diff -up chromium-62.0.3202.62/base/bind.h.epel7-c++11 chromium-62.0.3202.62/base/bind.h
--- chromium-62.0.3202.62/base/bind.h.epel7-c++11	2017-10-25 08:55:22.603877014 -0400
+++ chromium-62.0.3202.62/base/bind.h	2017-10-25 08:56:41.636714097 -0400
@@ -53,7 +53,7 @@ struct AssertConstructible {
   // reference with repeating callbacks--is used instead of base::Passed().
   static_assert(
       param_is_forwardable ||
-          !std::is_constructible<Param, std::decay_t<Unwrapped>&&>::value,
+          !std::is_constructible<Param, typename std::decay<Unwrapped>::type&&>::value,
       "Bound argument |i| is move-only but will be forwarded by copy. "
       "Ensure |Arg| is bound using base::Passed(), not std::move().");
   static_assert(
@@ -64,7 +64,7 @@ struct AssertConstructible {
   static constexpr bool arg_is_storable =
       std::is_constructible<Storage, Arg>::value;
   static_assert(arg_is_storable ||
-                    !std::is_constructible<Storage, std::decay_t<Arg>&&>::value,
+                    !std::is_constructible<Storage, typename std::decay<Arg>::type&&>::value,
                 "Bound argument |i| is move-only but will be bound by copy. "
                 "Ensure |Arg| is mutable and bound using std::move().");
   static_assert(arg_is_storable,
@@ -88,7 +88,7 @@ struct AssertBindArgsValidity<std::index
                               TypeList<Args...>,
                               TypeList<Unwrapped...>,
                               TypeList<Params...>>
-    : AssertConstructible<Ns, Args, std::decay_t<Args>, Unwrapped, Params>... {
+    : AssertConstructible<Ns, Args, typename std::decay<Args>::type, Unwrapped, Params>... {
   static constexpr bool ok = true;
 };
 
@@ -98,14 +98,14 @@ struct TransformToUnwrappedTypeImpl;
 
 template <typename T>
 struct TransformToUnwrappedTypeImpl<true, T> {
-  using StoredType = std::decay_t<T>;
+  using StoredType = typename std::decay<T>::type;
   using ForwardType = StoredType&&;
   using Unwrapped = decltype(Unwrap(std::declval<ForwardType>()));
 };
 
 template <typename T>
 struct TransformToUnwrappedTypeImpl<false, T> {
-  using StoredType = std::decay_t<T>;
+  using StoredType = typename std::decay<T>::type;
   using ForwardType = const StoredType&;
   using Unwrapped = decltype(Unwrap(std::declval<ForwardType>()));
 };
@@ -153,7 +153,7 @@ using MakeUnwrappedTypeList =
 template <typename Functor, typename... Args>
 inline OnceCallback<MakeUnboundRunType<Functor, Args...>>
 BindOnce(Functor&& functor, Args&&... args) {
-  static_assert(!internal::IsOnceCallback<std::decay_t<Functor>>() ||
+  static_assert(!internal::IsOnceCallback<typename std::decay<Functor>::type>() ||
                     (std::is_rvalue_reference<Functor&&>() &&
                      !std::is_const<std::remove_reference_t<Functor>>()),
                 "BindOnce requires non-const rvalue for OnceCallback binding."
@@ -197,7 +197,7 @@ template <typename Functor, typename...
 inline RepeatingCallback<MakeUnboundRunType<Functor, Args...>>
 BindRepeating(Functor&& functor, Args&&... args) {
   static_assert(
-      !internal::IsOnceCallback<std::decay_t<Functor>>(),
+      !internal::IsOnceCallback<typename std::decay<Functor>::type>(),
       "BindRepeating cannot bind OnceCallback. Use BindOnce with std::move().");
 
   // This block checks if each |args| matches to the corresponding params of the
diff -up chromium-62.0.3202.62/base/bind_internal.h.epel7-c++11 chromium-62.0.3202.62/base/bind_internal.h
--- chromium-62.0.3202.62/base/bind_internal.h.epel7-c++11	2017-10-25 08:52:20.018873878 -0400
+++ chromium-62.0.3202.62/base/bind_internal.h	2017-10-25 09:14:48.526096108 -0400
@@ -125,7 +125,7 @@ struct FunctorTraits;
 // to the function type while capturing lambdas can't.
 template <typename Functor>
 struct FunctorTraits<Functor,
-                     std::enable_if_t<IsConvertibleToRunType<Functor>::value>> {
+                     typename std::enable_if<IsConvertibleToRunType<Functor>::value>::type> {
   using RunType = ExtractCallableRunType<Functor>;
   static constexpr bool is_method = false;
   static constexpr bool is_nullable = false;
@@ -256,7 +256,7 @@ struct FunctorTraits<RepeatingCallback<R
 };
 
 template <typename Functor>
-using MakeFunctorTraits = FunctorTraits<std::decay_t<Functor>>;
+using MakeFunctorTraits = FunctorTraits<typename std::decay<Functor>::type>;
 
 // InvokeHelper<>
 //
@@ -341,7 +341,7 @@ struct Invoker<StorageType, R(UnboundArg
                           UnboundArgs&&... unbound_args) {
     static constexpr bool is_method = MakeFunctorTraits<Functor>::is_method;
 
-    using DecayedArgsTuple = std::decay_t<BoundArgsTuple>;
+    using DecayedArgsTuple = typename std::decay<BoundArgsTuple>::type;
     static constexpr bool is_weak_call =
         IsWeakMethod<is_method,
                      std::tuple_element_t<indices, DecayedArgsTuple>...>();
@@ -383,13 +383,13 @@ struct BindTypeHelper {
 };
 
 template <typename Functor>
-std::enable_if_t<FunctorTraits<Functor>::is_nullable, bool> IsNull(
+typename std::enable_if<FunctorTraits<Functor>::is_nullable, bool>::type IsNull(
     const Functor& functor) {
   return !functor;
 }
 
 template <typename Functor>
-std::enable_if_t<!FunctorTraits<Functor>::is_nullable, bool> IsNull(
+typename std::enable_if<!FunctorTraits<Functor>::is_nullable, bool>::type IsNull(
     const Functor&) {
   return false;
 }
@@ -479,33 +479,33 @@ struct MakeBindStateTypeImpl;
 
 template <typename Functor, typename... BoundArgs>
 struct MakeBindStateTypeImpl<false, Functor, BoundArgs...> {
-  static_assert(!HasRefCountedTypeAsRawPtr<std::decay_t<BoundArgs>...>::value,
+  static_assert(!HasRefCountedTypeAsRawPtr<typename std::decay<BoundArgs>::type...>::value,
                 "A parameter is a refcounted type and needs scoped_refptr.");
-  using Type = BindState<std::decay_t<Functor>, std::decay_t<BoundArgs>...>;
+  using Type = BindState<typename std::decay<Functor>::type, typename std::decay<BoundArgs>::type...>;
 };
 
 template <typename Functor>
 struct MakeBindStateTypeImpl<true, Functor> {
-  using Type = BindState<std::decay_t<Functor>>;
+  using Type = BindState<typename std::decay<Functor>::type>;
 };
 
 template <typename Functor, typename Receiver, typename... BoundArgs>
 struct MakeBindStateTypeImpl<true, Functor, Receiver, BoundArgs...> {
   static_assert(!std::is_array<std::remove_reference_t<Receiver>>::value,
                 "First bound argument to a method cannot be an array.");
-  static_assert(!HasRefCountedTypeAsRawPtr<std::decay_t<BoundArgs>...>::value,
+  static_assert(!HasRefCountedTypeAsRawPtr<typename std::decay<BoundArgs>::type...>::value,
                 "A parameter is a refcounted type and needs scoped_refptr.");
 
  private:
-  using DecayedReceiver = std::decay_t<Receiver>;
+  using DecayedReceiver = typename std::decay<Receiver>::type;
 
  public:
   using Type = BindState<
-      std::decay_t<Functor>,
+      typename std::decay<Functor>::type,
       std::conditional_t<std::is_pointer<DecayedReceiver>::value,
                          scoped_refptr<std::remove_pointer_t<DecayedReceiver>>,
                          DecayedReceiver>,
-      std::decay_t<BoundArgs>...>;
+      typename std::decay<BoundArgs>::type...>;
 };
 
 template <typename Functor, typename... BoundArgs>
diff -up chromium-62.0.3202.62/base/containers/span.h.epel7-c++11 chromium-62.0.3202.62/base/containers/span.h
--- chromium-62.0.3202.62/base/containers/span.h.epel7-c++11	2017-10-25 08:51:25.260372472 -0400
+++ chromium-62.0.3202.62/base/containers/span.h	2017-10-25 09:13:53.035964265 -0400
@@ -27,7 +27,7 @@ template <typename T>
 struct IsSpanImpl<span<T>> : std::true_type {};
 
 template <typename T>
-using IsSpan = IsSpanImpl<std::decay_t<T>>;
+using IsSpan = IsSpanImpl<typename std::decay<T>::type>;
 
 template <typename T>
 struct IsStdArrayImpl : std::false_type {};
@@ -36,7 +36,7 @@ template <typename T, size_t N>
 struct IsStdArrayImpl<std::array<T, N>> : std::true_type {};
 
 template <typename T>
-using IsStdArray = IsStdArrayImpl<std::decay_t<T>>;
+using IsStdArray = IsStdArrayImpl<typename std::decay<T>::type>;
 
 template <typename From, typename To>
 using IsLegalSpanConversion = std::is_convertible<From*, To*>;
@@ -51,7 +51,7 @@ using ContainerHasIntegralSize =
 
 template <typename From, typename To>
 using EnableIfLegalSpanConversion =
-    std::enable_if_t<IsLegalSpanConversion<From, To>::value>;
+    typename std::enable_if<IsLegalSpanConversion<From, To>::value>::type;
 
 // SFINAE check if Container can be converted to a span<T>. Note that the
 // implementation details of this check differ slightly from the requirements in
@@ -67,18 +67,18 @@ using EnableIfLegalSpanConversion =
 // container.
 template <typename Container, typename T>
 using EnableIfSpanCompatibleContainer =
-    std::enable_if_t<!internal::IsSpan<Container>::value &&
+    typename std::enable_if<!internal::IsSpan<Container>::value &&
                      !internal::IsStdArray<Container>::value &&
                      ContainerHasConvertibleData<Container, T>::value &&
-                     ContainerHasIntegralSize<Container>::value>;
+                     ContainerHasIntegralSize<Container>::value>::type;
 
 template <typename Container, typename T>
 using EnableIfConstSpanCompatibleContainer =
-    std::enable_if_t<std::is_const<T>::value &&
+    typename std::enable_if<std::is_const<T>::value &&
                      !internal::IsSpan<Container>::value &&
                      !internal::IsStdArray<Container>::value &&
                      ContainerHasConvertibleData<Container, T>::value &&
-                     ContainerHasIntegralSize<Container>::value>;
+                     ContainerHasIntegralSize<Container>::value>::type;
 
 }  // namespace internal
 
diff -up chromium-62.0.3202.62/ipc/ipc_message_templates.h.epel7-c++11 chromium-62.0.3202.62/ipc/ipc_message_templates.h
--- chromium-62.0.3202.62/ipc/ipc_message_templates.h.epel7-c++11	2017-10-25 09:15:02.382879317 -0400
+++ chromium-62.0.3202.62/ipc/ipc_message_templates.h	2017-10-25 09:15:36.609343836 -0400
@@ -67,7 +67,7 @@ void DispatchToMethodImpl(ObjT* obj,
 // The following function is for async IPCs which have a dispatcher with an
 // extra parameter specified using IPC_BEGIN_MESSAGE_MAP_WITH_PARAM.
 template <typename ObjT, typename P, typename... Args, typename Tuple>
-std::enable_if_t<sizeof...(Args) == std::tuple_size<std::decay_t<Tuple>>::value>
+typename std::enable_if<sizeof...(Args) == std::tuple_size<std::decay_t<Tuple>>::value>::type
 DispatchToMethod(ObjT* obj,
                  void (ObjT::*method)(P*, Args...),
                  P* parameter,
